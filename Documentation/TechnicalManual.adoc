= Metamorph technical manual
Martin Helmich <m.helmich@mittwald.de>
2015-01-11
:source-highlighter: coderay
:icons: font
:toc:

.Building this document
****

This is an *ASCIIdoc* document. To render it, you will need the `asciidoctor` and `pygments.rb` gems. You can then render it into an HTML document with the following command
line call:

----
asciidoctor -r asciidoctor-diagram TechnicalManual.adoc
----

Build the PDF using `wkhtmltopdf` with the following command line call:

----
wkhtmltopdf -T 20 -B 20 TechnicalManual.html TechnicalManual.pdf
----
****

== Architecture overview

== The domain model explained

=== Basic entities

["plantuml", "asciidoctor-diagram-classes", "png"]
---------------------------------------------------------------------
class MorphConfiguration {
	# name : string
	# sourceDirectory : string
	# tableStructureMode : enum[KEEP, MIGRATE]
}

interface ExtensionMatcher {
	match (extensionKey : string)
}

class AllMatcher
class UnionMatcher
class PatternMatcher {
	# pattern : string
}

AllMatcher --|> ExtensionMatcher
UnionMatcher --|> ExtensionMatcher
UnionMatcher *--> ExtensionMatcher
PatternMatcher --|> ExtensionMatcher

MorphConfiguration --> ExtensionMatcher

class ResourceMappingContainer {
	+ getResourceMappings() : ResourceMapping[]
	+ hasResourceMapping(sourceFile) : bool
	+ addResourceMapping(mapping : ResourceMapping)
	+ getResourceMapping(sourceFile) : ResourceMapping
}

class ClassMappingContainer {
	+ getClassMappings() : ClassMapping[]
	+ hasClassMapping(oldClassName) : bool
	+ addClassMapping(mapping : ClassMapping)
	+ getClassMapping(oldClassName) : ClassMapping
	+ getClassMappingByNewClassName(newClassName : string) : ClassMapping
	+ getClassMappingByFilter(filter : callable) : ClassMapping
}

class PackageMappingContainer {
	+ getPackageMappings() : PackageMapping[]
	+ hasPackageMapping(extensionKey) : bool
	+ addPackageMapping(mapping : PackageMapping)
	+ getPackageMapping(extensionKey) : PackageMapping
	+ getPackageMappingByFilter(filter : callable) : PackageMapping
	+ removePackageMapping(extensionKey)
}

class ResourceMapping {
	# sourceFile : string
	# targetFile : string
	# package : string
	# action : string
}

class ClassMapping {
	# sourceFile : string
	# oldClassName : string
	# newClassName : string
	# package : string
	# targetFile : string
	# action : string
}

class PackageMapping {
	# extensionKey: string
	# packageKey : string
	# filePath : string
	# action : string
	# description : string
	# version : string
	# authors : array<array<string,string>>
}

class Reviewable << (T,#FF7700) >> {
	# reviewed : bool
}

ResourceMappingContainer *--> ResourceMapping
ClassMappingContainer *--> ClassMapping
PackageMappingContainer *--> PackageMapping

MorphConfiguration --> ResourceMappingContainer
MorphConfiguration --> ClassMappingContainer
MorphConfiguration --> PackageMappingContainer

ResourceMappingContainer --|> Reviewable
ClassMappingContainer --|> Reviewable
PackageMappingContainer --|> Reviewable
---------------------------------------------------------------------

==== Morph configuration

The most central entity of the domain model is the `MorphConfiguration` class (unless otherwise noted, the `Mw\Metamorph\Domain\Model` namespace is implied for all classes). This is the entity that you create using the `morph:create` command and get presented using the `morph:list` command.

A morph configuration object has the following properties:

`name`:: This must be a valid TYPO3 Flow package key.
`sourceDirectory`:: The directory from where to import extensions. This usually should be the root directory of a TYPO3 CMS installation.
`tableStructureMode`:: The value of this property determines how Metamorph should treat an Extbase extension's table structure. If this value is `MIGRATE`, Metamorph will simply migrate your domain entity classes and then have _Doctrine_ generate a new table schema from the class definitions. If this value is `KEEP`, Metamorph will enrich your domain model classes with doctrine annotations so that the table schema stays identical to the Extbase version.
`extensionMatcher`:: This property contains a configuration on how TYPO3 extensions to be migrated should be selected. See the <<Extension selection>> section for more information.
`{package|class|resource}MappingContainer`:: See the <<Mapping configurations>> section for more information.

NOTE: The attributes `name`, `sourceDirectory`, `extensionMatcher` and `tableStructureMode` are queried by the morph creation wizard. All other properties are filled dynamically by transformation steps when the morph configuration is actually executed.

==== Extension selection

Each morph configuration object is associated to an `ExtensionMatcher` object. This object determines which extensions from the source TYPO3 site should be migrated to Flow. The `ExtensionMatcher` object looks as follows:

[source,php]
----
namespace Mw\Metamorph\Domain\Model\Extension;

interface ExtensionMatcher
{
    public function match($extensionKey);
}
----

When creating a morph configuration using the CLI wizard, you will typically get one or several instances of the `PatternExtensionMatcher` class, which contains a regular expression that extension keys must match in order to be migrated.

==== Mapping configurations

The _mapping configurations_ describe what should happen to individual source items during the migration process. For example, the _package mapping_ describes, which TYPO3 extensions should be migrated to Flow packages, which package keys should be used and what metadata to write into the target package's `composer.json`.

Package mapping:: Describes *for each TYPO3 extension*, (1) whether to migrate this extension or not, (2) which package key to use and (3) what metadata to write into the `composer.json` file (author, description, versions, ...).

Class mapping:: Describes *for each PHP class* in all migrated extensions, (1) whether to migrate this class or not, (2) which (new) class name to use and (3) in which package the class should be migrated.

Resource mapping:: Describes *for each resource file* in all migrated extensions, (1) whether to migrate this resource or not and (2) to which location in the file system the resource should be migrated.

NOTE: Typically, the package, class and resource mappings are auto-generated during one of the first transformation steps. During this process, Metamorph will make assumptions concerning package keys (see <<Building the package map>>), new class names (see <<Building the class map>>) and resource file names (see <<Building the resource map>>). These can then be manually edited later.

In order to prevent apocalyptic scenarios, Metamorph will require auto-generated mappings to be reviewed by the user before doing anything. While Metamorph is capable of performing quite sound assumptions when migrating Extbase extensions, converting pibase extensions is largely guesswork.

==== Class schemata

The `ClassDefinition` and `PropertyDefinition` classes model a TYPO3 extension's class schema. You can use these classes to inquire (and store) facts about classes and properties.

NOTE: The class schema is built during run-time (see the <<Analyzing the class definitions>> section).

A common use case might be to inqure about inheritance hierarchies in the source code:

[source,php]
----
class SomeTransformation {
  /**
   * @var \Mw\Metamorph\Domain\Model\ClassDefinitionContainer
   * @Flow\Inject
   */
  protected $classDefinitionContainer; // <1>

  public function execute(MorphConfiguration $configuration) {
    $frontendUserSubclasses = $this
      ->classDefinitionContainer
      ->findByFilter(function(ClassDefinition $d) {
        return
          $d->doesInherit('TYPO3\\CMS\\Extbase\\Domain\\Model\\FrontendUser') ||
          $d->doesInherit('Tx_Extbase_Domain_Model_FrontendUser'); // <2>
        });

    // Do some magic!
  }
}
----
<1> You can access the class definitions by injecting the `Mw\Metamorph\Domain\Model\ClassDefinitionContainer` class (it's a singleton).
<2> Metamorph *does not* resolve compatibility class names (yet). If you want to transform older TYPO3 extensions too, you should also check for legacy class names.

=== Persistence

Persisting the domain entities is not a concern of the domain model. The actual persistence logic is embedded in proxy classes that are organized in the `Mw\Metamorph\Persistence` namespace. All persistence classes use YAML files as storage backend (optionally, with a Git repository as versioning backend).

IMPORTANT: Usually, you should never use these classes! Access to the persistence layer is encapsulated by the `MorphConfigurationRepository` class.

As the `MorphConfiguration` class is always the aggregate root, the `MorphConfigurationWriter` class should always be used for persisting morph configurations. The writer will dump the entire aggregate into YAML files and store these in a TYPO3 Flow package. The morph configuration name will be used as package name.

==== Morph configurations

The following example shows a persisted morph configuration:

[source,yaml]
----
sourceDirectory: /home/mhelmich/dev/typo3-extbasefluid-examplesite/html
extensions:
    - { pattern: /^helmich_/ }
    - { pattern: /^mittwald_/ }
tableStructureMode: MIGRATE
pibaseRefactoringMode: PROGRESSIVE
----

==== Class mapping

The following example shows a persisted class mapping configuration:

[source,yaml]
----
reviewed: true
classes:
  Sjr\SjrOffers\Controller\OrganizationController:
    source: typo3conf/ext/sjr_offers/Classes/Controller/OrganizationController.php
    newClassname: Sjr\Offers\Controller\OrganizationController
    package: Sjr.Offers
    action: MORPH
    target: Classes/Sjr/Offers/Controller/OrganizationController.php
  Sjr\SjrOffers\Controller\OfferController:
    source: typo3conf/ext/sjr_offers/Classes/Controller/OfferController.php
    newClassname: Sjr\Offers\Controller\OfferController
    package: Sjr.Offers
    action: MORPH
    target: Classes/Sjr/Offers/Controller/OfferController.php
  Sjr\SjrOffers\Domain\Model\Region:
    source: typo3conf/ext/sjr_offers/Classes/Domain/Model/Region.php
    newClassname: Sjr\Offers\Domain\Model\Region
    package: Sjr.Offers
    action: MORPH
    target: Classes/Sjr/Offers/Domain/Model/Region.php
  Sjr\SjrOffers\Service\AccessControlService:
    source: typo3conf/ext/sjr_offers/Classes/Service/AccessControlService.php
    newClassname: Sjr\Offers\Service\AccessControlService
    package: Sjr.Offers
    action: MORPH
    target: Classes/Sjr/Offers/Service/AccessControlService.php

# ...
----

=== Constraints

There are some constraints that the current state of the domain model entities must always fulfil. Since the transformation steps may change the domain entities, these constraints are checked before and after each transformation step. This is done using aspects of Flow's AOP framework.

Currently, the following constraints are asserted before each transformation step:

* The domain entities must be in a valid state. This means for example, that all required values are set, and the package mapping must contain valid TYPO3 Flow package keys.
* Package, class and resource mapping must be reviewed. Whenever new values are automatically added to any of these mapping configurations, they are flagged as _unreviewed_. Metamorph will then deny any destructive operations until the changed to the mapping configuration have been reviewed. This is a safeguard against potentially harmful transformations.

=== Transformations

When executing a morph, Metamorph will execute a series of _transformations_; typically these will somehow process your source TYPO3 CMS installation and modify the local TYPO3 Flow installation.

Each transformation step is modelled as a PHP class that needs to implement the interface `Mw\Metamorph\Transformation\Transformation`, as shown in the following listing. Typically though, you should use the class `Mw\Metamorph\Transformation\AbstractTransformation`, as this class already implements some of the basic functionality.

.The transformation interface
[source,php]
----
namespace Mw\Metamorph\Transformation;

use Mw\Metamorph\Domain\Model\MorphConfiguration;
use Mw\Metamorph\Domain\Service\MorphExecutionState;
use Symfony\Component\Console\Output\OutputInterface;

interface Transformation {
    public function setSettings(array $settings);
    public function execute(
        MorphConfiguration $configuration,
        MorphExecutionState $state,
        OutputInterface $out // <1>
    );
}
----
<1> Don't depend on the `$out` parameter. It's likely to be deprecated.

Metamorph comes with a set of bundled transformations, that _should_ handle most of the issues that arise when migrating Extbase or pibase extensions. These are organized in the `Mw\Metamorph\Step` namespace. They will be looked at in more detail in a later section of this document.

The transformations that are executed are specified in the settings, in special in the `Mw.Metamorph.transformations` property. Have a look at the following listing to see how the transformations and their execution order is specified:

.Specifying transformations and execution order in the package configuration
[[metamorph-settings]]
[source,yaml]
----
Mw:
  Metamorph:
    transformations:
      extensionInventory:
        name: ExtensionInventory # <1>
      classInventory:
        name: ClassInventory
        dependsOn: [extensionInventory] # <2>
        settings: # <3>
          visitors: []
      resourceInventory:
        name: ResourceInventory
        dependsOn: [extensionInventory]
      createPackages:
        name: CreatePackages:
        dependsOn: [extensionInventory, classInventory, resourceInventory]
----
<1> This is a class name. If you specify an unqualified class name, Metamorph will assume the namespace `Mw\Metamorph\Transformation` for this class.
<2> You can specify dependencies for each transformation step. Metamorph will determine the final execution order of all transformation steps using _topological sorting_.
<3> Some transformations allow you to pass custom settings. These will be passed into the `setSettings` method of the transformation class.

As you may have guessed, you are free to add additional transformation steps to this list in the settings of your own packages. This allows you to extend and modify Metamorph's default transformation process according to your own custom requirements.

TIP: When overwriting/extending another package's settings, remember to add the `mittwald-typo3/metamorph` dependency to your own package's `composer.json`. TYPO3 Flow uses the Composer dependency graph to figure out in which order the settings should be merged.

== Existing transformations

=== Building the package map

The `Mw\Metamorph\Step\ExtensionInventory` step should be the first transformation to be executed (although it does not actually transform anything, yet). It will perform the following actions:

- Go into the source directory of the current morph configuration (remember, the source directory is the root directory of a TYPO3 CMS installation) and scan the `typo3conf/ext` directory for TYPO3 extensions.
- Apply the _extension matcher_ (see <<Extension selection>> for more information) of the current configuration *on each extension* to check whether the extension should be migrated to the current TYPO3 Flow installation.
- For each extension that should be migrated:

  * Try to guess a good TYPO3 Flow package key (and yes, this is actually mostly guesswork!). This is done using the following algorithm (pseudocode):
+
[source,java]
----
extensionKey
  .split('_')
  .map((word : string) => word.firstLetterToUppercase())
  .join('.')
----
+
NOTE: This algorithm is not optimal! It will not always generate valid package keys, so sometimes, manual adjustments may be necessary. See the explanation box below for more information.

  * Extract metadata (like description and author information) from the TYPO3 extension's `ext_emconf.php` file.

  * Create a new package mapping from the TYPO3 extension.

.On package name generation
****

As you may have noticed, the automatic package name generation does not produce optimal results in all cases. In some cases, manual adjustments might be necessary. Metamorph will try to warn you about invalid or otherwise dangerous package names. However, while these are easy to find, they are difficult to fix automatically, so some manual adjustments might be needed.

The table below contains some examples on how extension keys are converted to package keys (along with some typical pitfalls):

|===
|Extension key |Package key |Remarks

|`mw_example`
|`Mw.Example`
|Valid! Yay!

|`example`
|`Example`
|Invalid, no vendor prefix

|`mw_example_advanced`
|`Mw.Example.Advanced`
|Valid per se, but PSR-0 namespaces overlap with `Mw.Example`
|===

****

=== Building the class map

The `Mw\Metamorph\Step\ClassInventory` step should be executed *after* the package map generation. It will perform the following actions:

- *For each* package from the package mapping,

  * Find all PHP files. Parse the PHP files and look for class definitions.
  * *For each PHP class*, use the package name and try to generate a class name that fits into the PSR-0 prefix of the package namespace.
  * Create a new class mapping for each PHP class.

.On class name generation
****
Metamorph tries to automatically determine a class name (and namespace) that fits into the PSR-0 namespace root of the containing package. This usually works well for Extbase classes that follow certain conventions, but is mainly guesswork for pibase extensions that are named without any fixed conventions. There are some special rules for plugin classes (like `tx_<extkey>_pi1`), though. Consider the following table for some examples on generated class names (the root namespace is `Mw\Example` in all cases):

|===
|Old class name |New class name |Remarks

|`Mw\MwExample\Controller\FooController`
|`Mw\Example\Controller\FooController`
|

|`Tx_MwExample_Controller_FooController`
|`Mw\Example\Controller\FooController`
|

|`tx_mwexample_pi1`
|`Mw\Example\Plugin\Pi1`
| You should rename that one! `Pi1` is not a good class name.
|===

****

=== Building the resource map

The `Mw\Metamorph\Step\ResourceInventory` step should be executed *after* the package map generation. It will perform the following actions:

- *For each* package from the package mapping,

  * Find all resource files. Files are found by their *file extension*.
  * Determine where the file should be stored in the migrated TYPO3 Flow package. While Extbase extensions follow the same pattern as Flow packages (with a `Resources/` directory and `Private` and `Public` subdirectories), in pibase extensions, resource files can actually be found anywhere. By default, Metamorph will try to categorize found resource files by their extension into groups and then move these into respective subdirectories.
+
This is entirely configurable. The entire resource mapping is stored in the `Mw.Metamorph.resourceExtensions` setting:
+
.Definition of resource mappings in the package settings
[source,yaml]
----
Mw:
  Metamorph:
    resourceExtensions:
      templates:
        targetPath: Private/Templates
        extensions: [html, htm]
      languageFiles:
        targetPath: Private/Language
        extensions: [xml, xlf]
      images:
        targetPath: Public/Images
        extensions: [jpeg, jpg, gif, tif, svg, eps, png]
      javascript:
        targetPath: Public/JavaScript
        extensions: [js, coffee, ts]
      css:
        targetPath: Public/Stylesheets
        extensions: [css, sass, less, scss]
----

=== Clean up packages

When you are migrating continuously, it is entirely possible that your local TYPO3 Flow instance already contains some of the packages that would be created during migration. This step, modelled by the class `Mw\Metamorph\Step\CleanupPackages`, will clean up each target package so that migration is easily possible:

. If you are using a source control system like Git, Metamorph will checkout the `metamorph` branch before actually doing anything. When the migration was completed, Metamorph will try to merge the `metamorph` branch back into your `master` branch.
. Otherwise, Metamorph will delete the package and have the next transformation step re-create it.

=== Create packages

The `Mw\Metamorph\Step\CreatePackages` step will now create all TYPO3 Flow packages that are specified in the _package mapping_. For this, Metamorph will use TYPO3 Flow's http://typo3.org/api/flow/TYPO3/Flow/Package/class-PackageManager.html[APIs for package management]:

[source,php]
----
foreach ($packageMappingContainer->getPackageMappings() as $packageMapping) {
    if (FALSE === $this->packageManager->isPackageAvailable($packageMapping->getPackageKey())) {
        $this->packageManager->createPackage(
            $packageMapping->getPackageKey(),
            $this->createPackageMetaData($packageMapping),
            NULL,
            'typo3-flow-package'
        );
    }
}
----

The package meta data (description, authors) will be migrated from the source extension.

=== Migrate classes and resources

These are actually two steps: `Mw\Metamorph\Step\CreateClasses` and `Mw\Metamorph\Step\CreatePackages`. Each of these steps walks the _class mapping_ (or _resource mapping_, respectively) and copies each file to the target location in the new TYPO3 Flow site.

Classes are stored in the target package's _Classes/_ directory according to their class name (this is required, because they need to be auto-loadable). Resource files are simply placed in the target directory that is specified in the _resource mapping_.

=== Rename classes

This step renames all classes that were copied in the previous step according to the _class mapping_ configuration. The PHP class for this transformation is actually generic (`Mw\Metamorph\Transformation\GenericAstVisitorTransformation`) and is used again in later steps. This transformation class does the following:

[options="compact"]
. Parse each PHP class file into a syntax tree
. Traverse the syntax tree and apply a configurable set of node visitors
. Dump the modified syntax tree back into the target file

See <<Modifying source code inside transformations>> for more information.

In this case, this transformation step specifically does the following:

. Resolve class imports. This means that everytime, a class is imported with a `use` statement and then used with it's relative name somewhere in the code, this usage will simply be replaced with the fully-qualified class name.
+
[cols="1a,1a"]
|===
|Before | After

|

[source,php]
----
use Foo\Bar;
use Bar\Baz;

class Baz extends Bar {
    protected $foo;
    public function __construct() {
        $this->baz = new Baz();
    }
}
----

|

[source,php]
----
use Foo\Bar;
use Bar\Baz;

class Baz extends \Foo\Bar {
    protected $foo;
    public function __construct() {
        $this->baz = new \Bar\Baz();
    }
}
----
|===
+
. For each class definition, look for the fully-qualified class name in the _class mapping_. Then replace the class definition with the new class name. When the class definition is inside a namespace statement, change the namespace name accordingly. When the class definition is **not inside a namespace statement**, wrap the entire file in a namespace statement according to the new class name.
+
[cols="1a,1a"]
|===
|Before | After

|

[source,php]
----
class Old_Baz extends \Foo\Bar {
    protected $foo;
    public function __construct() {
        $this->baz = new \Bar\Baz();
    }
}
----

|

[source,php]
----
namespace New;
class UberBaz extends \Foo\Bar {
    protected $foo;
    public function __construct() {
        $this->baz = new \Bar\Baz();
    }
}
----

|

[source,php]
----
namespace Old;
class Baz extends \Foo\Bar {
    protected $foo;
    public function __construct() {
        $this->baz = new \Bar\Baz();
    }
}
----

|

[source,php]
----
namespace New;
class UberBaz extends \Foo\Bar {
    protected $foo;
    public function __construct() {
        $this->baz = new \Bar\Baz();
    }
}
----

|===
+
. For each **class usage** like constructor calls, static method calls, inheritance and constant usages, replace the class name when a class mapping is defined.
+
[cols="1a,1a"]
|===
|Before | After

|

[source,php]
----
namespace New;
class Baz extends \Old\Bar {
    protected $foo;
    public function __construct() {
        $this->baz = new \Old\Baz();
    }
}
----

|

[source,php]
----
namespace New;
class Baz extends \New\Bar {
    protected $foo;
    public function __construct() {
        $this->baz = new \New\Baz();
    }
}
----
|===
+
. Look for the class name in strings and doc comments. Replace the class name when a class mapping for this class is defined.
+
[cols="1a,1a"]
|===
|Before | After

|

[source,php]
----
namespace New;
class Baz extends \New\Bar {
    /** @var \Old\Baz */
    protected $foo;
    public function __construct() {
        $class = "Old\\Baz";
        $this->baz = new $class();
    }
}
----

|

[source,php]
----
namespace New;
class Baz extends \New\Bar {
    /** @var \New\Baz */
    protected $foo;
    public function __construct() {
        $class = "New\\Baz";
        $this->baz = new $class();
    }
}
----
|===


=== Analyzing the class definitions

The `Mw\Metamorph\Step\AnalyzeClasses` step will iterate over each class from the _class mapping_ and analyze the class' inheritance structure and properties. This information is then stored in the _class definition container_. See <<Using the class definition container>> for more information on the _class definition container_.

=== Refactorings

This is the main transformation step. It uses the `Mw\Metamorph\Transformation\GenericAstVisitorTransformation` class already introduced in <<Rename classes>>. This step applies a number of transformation visitors to the syntax tree of each class. The following list briefly outlines the purpose of each node visitor (all classnames in the `Mw\Metamorph\Step\TransformationVisitor` namespace):

ExtbaseClassReplacementVisitor::
    Replaces extbase classes with their TYPO3 Flow equivalents. An example would be the `TYPO3\CMS\Extbase\Mvc\Controller\ActionController` class which is replaced by the `TYPO3\Flow\Mvc\Controller\ActionController` class. The classes that should be replaced can be configured in the configuration setting `Mw.Metamorph.staticReplacements`.

EntityDoctrineMigrationVisitor::
    Migrates entity and value object classes to _Doctrine_. This affects all classes that (*directly or indirectly*) inherit `TYPO3\CMS\Extbase\DomainObject\AbstractEntity` or `TYPO3\CMS\Extbase\DomainObject\AbstractValueObject` (or their legacy `Tx_`-style equivalents). Classes that directly inherit one of these classes will have this inheritance removed, as Doctrine works with plain objects. Instead, appropriate `@Flow\Entity` annotations will be added.
+
IMPORTANT: Metamorph will convert Extbase value objects (inheriting `TYPO3\CMS\Extbase\DomainObject\AbstractValueObject`) to *entity classes*. The reason for this is that Flow puts much stricter constraints on value objects than Extbase. For example, value objects must be truly *immutable* in Flow (all properties need to be set using constructor arguments, and setter methods are not allowed). Extbase is much more lenient on this and actually allows value objects to be mutable. Because of this, it makes more sense to convert them into entities, instead.

ReplaceMakeInstanceCallsVisitor::
    This visitor replaces calls to `TYPO3\CMS\Core\Utility\GeneralUtility::makeInstance`. For singleton objects (these always implement the `TYPO3\CMS\Core\SingletonInterface`), these calls are replaced with a dependency injection. For prototype-scoped objects, the `makeInstance` call is replaced by a simple constructor call.
+
.Example: Simple string argument, prototype-scoped
[cols="1a,1a"]
|===
|Before | After

|
[source,php]
----
class Foo {
  public function foo() {
    $bar = t3lib_div::makeInstance('Bar');
  }
}
----
|
[source,php]
----
class Foo {
  public function foo() {
    $bar = new Bar();
  }
}
----
|===
+
.Example: Simple string argument, singleton-scoped
[cols="1a,1a"]
|===
|Before | After

|
[source,php]
----
class Foo {
  public function foo() {
    $bar = t3lib_div::makeInstance('Bar');
  }
}
----
|

[source,php]
----
class Foo {
  /** @var Bar
    * @Flow\Inject */
  protected $bar;
  public function foo() {
    $bar = $this->bar;
  }
}
----

|===
+
.Example: Complex expression argument, prototype-scoped
[cols="1a,1a"]
|===
|Before | After

|
[source,php]
----
class Foo {
  public function foo($baz) {
    $bar = t3lib_div::makeInstance(
      $baz . 'Object', 123);
  }
}
----
|

[source,php]
----
class Foo {
  public function foo($baz) {
    $_b7c620c5 = $baz . 'Object'; // <1>
    $bar = new $_b7c620c5(123);
  }
}
----
<1> A temporary variable is really necessary here. The expression `$bar = new $baz . 'Object'()` is syntactically *really* wrong.

|===
+
.Example: Complex expression argument, singleton-scoped
[cols="1a,1a"]
|===
|Before | After

|
[source,php]
----
class Foo {
  public function foo($baz) {
    $bar = t3lib_div::makeInstance(
      $baz . 'Object');
  }
}
----
|

[source,php]
----
class Foo {
  /** @var ObjectManager
   *  @Flow\Inject */
  protected $objectManager;
  public function foo($baz) {
    $bar = $this->objectManager->get(
      $baz . 'Object');
  }
}
----

|===
+
RewriteSingletonsVisitor::
    This visitor affects all classes that implement the `TYPO3\CMS\Core\SingletonInterface` interface (or it's legacy variant `t3lib_Singleton`). The interface implementation will be removed, and a `@Flow\Scope("singleton")` annotation added to the class.

ReplaceAnnotationsVisitor::
    This visitor replaces all Extbase annotations with their Flow equivalents; this is mostly search&replace (for example `@inject` becomes to `@Flow\Inject`). Some annotations require some more logic; for example `@validate StringLength(minLength=3)` needs to be converted to `@Flow\Validate(type="StringLength", options={"minLength"=3})`. Currently, these replacements are hardcoded in the `ReplaceAnnotationsVisitor` class. Have a look there for more information.

InjectUtilitiesVisitor::
    This visitor replaces all kinds of utility calls (most prominently the infamous `GeneralUtility` class). Although Metamorph does provide a compatibility layer for these classes (actually, the package `Mw.T3Compat` does), these classes do not allow their methods to be called statically. This is because the compatibility classes themselves depend on Flow APIs that do not allow static method calls. To fix this issue, all static utility calls are replaced with instance calls on a utility instance that is injected via dependency injection.
+
.Example: GeneralUtility instance being injected
[cols="1a,1a"]
|===
|Before | After

|
[source,php]
----
class Foo {
  public function foo($baz) {
    $bar = GeneralUtility::trimExplode(
      $baz);
  }
}
----
|

[source,php]
----
class Foo {
  /** @var GeneralUtility
   *  @Flow\Inject */
  protected $generalUtility;
  public function foo($baz) {
    $bar = $this->generalUtility
      ->trimExplode($baz);
  }
}
----

|===
+
FlashMessageVisitor::
    This visitor fixes some outdated usages of the `FlashMessageContainer` class. Basically, all this visitor does is converting `$this->flashMessages->add('foo')` to `$this->addFlashMessage('foo')`. That's it.

PackageRedirectVisitor::
    This visitor fixes usages of `redirect` method offered by the `ActionController`. Upon calling this method, you can specify an extension key. When this method is called with an extension key, this extension key needs to be replaced with the corresponding TYPO3 Flow package key. This key can easily be retrieved from the _package mapping_, if set. It becomes more difficult, when the extension key parameter is not a string literal, but a dynamic expression. In this case, Metamorph will create a lookup table from the package mapping.
+
.Example: `redirect` call with string literal argument
[cols="1a,1a"]
|===
|Before | After

|
[source,php]
----
public function fooAction() {
  $this->redirect(
    'show',
    'Controller',
    'my_extension'
  );
}
----
|

[source,php]
----
public function fooAction() {
  $this->redirect(
    'show',
    'Controller',
    'My.Package'
  );
}
----

|===
+
.Example: `redirect` call with dynamic expression argument
[cols="1a,1a"]
|===
|Before | After

|
[source,php]
----
public function fooAction($target) {
  $this->redirect(
    'show',
    'Controller',
    $target
  );
}
----
|

[source,php]
----
public function fooAction($target) {
  $metamorphExtensions = [
    'my_extension' => 'My.Package'
  ];
  $this->redirect(
    'show',
    'Controller',
    $metamorphExtensions[$target]
  );
}
----

|===

=== Locallang transformation

Extbase still allows using locallang XML files for translation handling. This is a TYPO3-proprietary format that is not supported by TYPO3 Flow. These files will be converted into the XLIFF format (which is an OASIS standard). This is done by a XSLT transformation that is executed in the `Mw\Metamorph\Step\MigrateDatabaseStructure` step. Have a look at the XSLT stylesheet in `Resources/Xslt` if you are interested in further details.

=== Database migration

In this step, Metamorph will enrich the migrated domain entity classes by the necessary doctrine annotations. For this, Metamorph parses the source extension's _Table Configuration Array_ (short _TCA_) and extracts all necessary mapping information. Depending on your configuration, the following things will happen:

. The domain models will be extended by Doctrine anntations for http://doctrine-orm.readthedocs.org/en/latest/reference/association-mapping.html[association mapping] (like for example `@ORM\OneToMany(inversedBy="foo")`.
+
.Example on association mapping
****
Consider an entity class `My\Example\Domain\Model\Product` with the following _TCA_:

[source,php]
----
$TCA['tx_example_domain_model_product']['columns']['inventory_changes'] = [
    'config' => [
        'type'          => 'inline',
        'maxitems'      => 9999,
        'foreign_table' => 'tx_example_domain_model_inventorychange',
        'foreign_field' => 'product'
    ]
];
----

IMPORTANT: Remember that Extbase expects database columns to be `under_scored`, and entity attribute names to be `camelCased`. Extbase automatically converts between these two notations, and so does Metamorph. This means that whenever you see a _database column_ like `inventory_changes`, this will be actually mapped to a property named `inventoryChanges`.

Altough it is not specifically labeled as such, an `inline` relation in the TCA is actually a 1:n relation. This relation is stored in the `inventoryChanges` property of the `Product` class. Metamorph would now add the following annotations to this property:

[source,php]
----
class Product {
    /**
     * @ORM\OneToMany(mappedBy="product") // <1>
     * @var Collection<InventoryChange>
     */
    protected $inventoryChanges;
}
----
<1> Here, `product` is the `foreign_field` value from the TCA.

Furthermore, Metamorph will adjust the inverse property, too. Typically, the `InventoryChange` class should have a `product` property.

IMPORTANT: If there is no inverse property for an 1:n relationship, Metamorph will add one!

[source,php]
----
class InventoryChange {
    /**
     * @ORM\ManyToOne(inversedBy="inventoryChanges") // <1>
     * @var Product
     */
    protected $product;
}
----
<1> Here, `inventoryChanges` is the name of the property in the target entity.
****
+
. Optionally, Metamorph will add Doctrine annotations so that table and column names match the old Extbase mapping! This includes adding a `uid` column to all tables and declaring it as identifier.
+
.Example on compatibility mapping
****
Consider the following entity class:

[source,php]
----
/**
 * @Flow\Entity
 */
class Product {
    /**
     * @var string
     */
    protected $longDescription;

    /**
     * @var Collection<InventoryChange>
     * @ORM\OneToMany(mappedBy="product")
     */
    protected $inventoryChanges;
}
----

In compatibility mode, Metamorph would modify this class as follows:

[source,php]
----
/**
 * @Flow\Entity
 * @ORM\Table(name="tx_example_domain_model_product") <1>
 */
class Product {
    /**
     * @var int
     * @Flow\Identity
     * @ORM\GeneratedValue
     */
    protected $uid; // <2>

    /**
     * @var string
     * @ORM\Column(name="long_description") <3>
     */
    protected $longDescription;

    /**
     * @var Collection<InventoryChange>
     * @ORM\OneToMany(mappedBy="product")
     */
    protected $inventoryChanges;
}
----
<1> Here, Metamorph will insert the original table name. Without this annotation, Flow would auto-generate a table name like `my_example_domain_model_product` (note the different namespace).
<2> This attribute is added automatically, because TYPO3 Extbase adds a `uid` column to all entities by convention. The `@Flow\Identity` marks this attribute as the primary key and the `@ORM\GeneratedValue` causes Doctrine to rely on the DBMS' auto-incrementing key. Without this attribute, Flow would auto-generate a `persistence_object_identifier` property with UUID values.
<3> The value `long_description` is loaded from the original TCA. By default, Flow would use `longdescription` as column name.
****

== Using the class definition container

You have access to the class definitions after the _class analyzation step_ has been run. You can then inject an instance of the `Mw\Metamorph\Domain\Model\Definition\ClassDefinitionContainer` class into your own class and use this class to find class definitions that match certain constraints.

The following code example gets all class definitions that inherit from one of Extbase's _FrontendUser_ classes:

[source,php]
----
use Mw\Metamorph\Transformation\AbstractTransformation;
use Mw\Metamorph\Domain\Model\Definition\ClassDefinitionContainer;
use TYPO3\Flow\Annotations as Flow;

class MyTransformation extends AbstractTransformation {

    /**
     * @var ClassDefinitionContainer
     * @Flow\Inject
     */
    protected $container;

    public function execute(MorphConfiguration $configuration, MorphExecutionState $state) {
        $userClasses = $this->container->findByFilter(function(ClassDefinition $c) {
            return
                $c->doesInherit('Tx_Extbase_Domain_Model_FrontendUser') ||
                $c->doesInherit('TYPO3\\CMS\\Extbase\\Domain\\Model\\FrontendUser');
        }); // <1>

        foreach ($userClasses as $userClass) {
            $classMapping = $userClass->getClassMapping(); // <2>

            foreach ($userClass->getProperties() as $property) { // <3>
                // Do some magic.
            }
        }
    }
}
----
<1> Use the `findByFilter` function with a callback to execute arbitrary queries.
<2> Each class definition is associated to the respective class mapping.
<3> Each class definition is associated to property definitions.

== Facts

After the class analyzation step (see <<Analyzing the class definitions>>), Metamorph will offer access to a series of _facts_ about each class that can be used in subsequent transformation steps.

You can query facts about a specific class definition by calling the `getFact` method on any `ClassDefinition` object:

.Retrieving facts from class definitions
[source,php]
----
$classDefinition = $this->classDefinitionContainer->get('My\\Example\\Class');
if ($classDefinition->getFact('isSingleton')) {
    // ...
}
----

You can also set you own facts for existing class definitions by calling the `setFact` method at any time:

.Setting facts for individual class definitions
[source,php]
----
$classDefinition = $this->classDefinitionContainer->get('My\\Example\\Class');
$classDefinition->setFact('myFactName', TRUE); // <1>
----
<1> The second parameter can be an arbitrary value.

=== Predefined facts

The following list presents a list of the predefined facts that can be used without further configuration:

isAbstract::
	_True_ for abstract classes.
isFinal::
	_True_ for final classes.
isEntity::
	Is _true_ when the class inherits from the `TYPO3\CMS\Extbase\DomainObject\AbstractEntity` class (or it's legacy variant `Tx_Extbase_DomainObject_AbstractEntity`). This is also true for transitive inheritance.
isValueObject::
	Same as `isEntity`, except for value objects (inheriting the `TYPO3\CMS\Extbase\DomainObject\AbstractValueObject` class or it's legacy variant).
isEntityOrValueObject::
	Should be self-explanatory.
isSingleton::
	Is _true_ when the class is marked as _singleton-scoped_. This is the case when the class or any of it's parent classes implement the `TYPO3\CMS\Core\SingletonInterface` or it's legacy variant `t3lib_Singleton`.
isPrototype::
	Negation of `isSingleton`.
isDirectEntityDescendant::
	_True_ when the class directly inherits `TYPO3\CMS\Extbase\DomainObject\AbstractEntity` (or it's legacy variant).
isDirectValueObjectDescendant::
	_True_ when the class directly inherits `TYPO3\CMS\Extbase\DomainObject\AbstractValueObject` (or it's legacy variant).
isDirectEntityOrValueObjectDescendant::
	Should be self-explanatory.

=== Defining new facts

==== As PHP classes

Facts are defined by configuration in the `Mw.Metamorph.facts` setting. Dynamic facts are described by the `Mw\Metamorph\Domain\Model\Definition\Fact` interface, which needs to be implemented by custom facts:

.The `Fact` interface
[source,php]
----
<?php
namespace Mw\Metamorph\Domain\Model\Definition;

interface Fact {
    public function evaluate(ClassDefinition $classDefinition);
}
----

As you can see, each dynamic fact operates on a single class definition. You can implement a new fact using this interface:

.Example for a custom fact implementation
[source,php]
----
class IsFrontendUserFact implements Fact {
    public function evaluate(ClassDefinition $class) {
        return
            $class->doesInherit('TYPO3\\CMS\\Extbase\\Domain\\Model\\FrontendUser') ||
            $class->doesInherit('Tx_Extbase_Domain_Model_FrontendUser');
    }
}
----

You can then register this fact in the settings:

.Example for registering new fact classes
[source,yaml]
----
Mw:
  Metamorph:
    facts:
      isFrontendUser: # <1>
        class: My\Example\Facts\IsFrontendUserFact
----
<1> This is the actual name of the fact that you will have to supply later-on when retrieving the fact by the `getFact` method.

When your fact is registered like this, you can access it at any time after the _class analyzation_ step, by simply calling `getFact` on any class definition:

[source,php]
----
$class = $this->classDefinitionContainer->get('My\\Example\\Class');
$class->getFact('isFrontendUser');
----

==== As EEL expression

As you may have noticed, many of the existing facts follow more or less the same pattern: checking for certain inheritance or implememtation patterns on the given classes. Since most facts only re-use some of the already-known facts about each class, there is an easier way to define these kinds of facts.

You can declare a fact as an EEL expression (not much reading on this subject, the best I could find is from the http://docs.typo3.org/neos/TYPO3NeosDocumentation/IntegratorGuide/EelFlowQuery.html[TYPO3 Neos manual]). In an EEL expression, you have access to the class definition object inside the `class` variable and can then call any method you like.

For example, the _isSingleton_ fact that you saw in <<Predefined facts>> is actually an EEL expression:

[source,eel]
----
class.doesImplement('TYPO3\\CMS\\Core\\SingletonInterface') ||
class.doesImplement('t3lib_Singleton') ||
(class.getParentClass() != null && class.getParentClass().getFact('isSingleton')) ||
class.doesInherit('TYPO3\\CMS\\Extbase\\Persistence\\Repository') ||
class.doesInherit('Tx_Extbase_Persistence_Repository')
----

You can declare EEL-based facts just as easily in the configuration settings. Let's stay with the frontend user example from the previous section:

[source,yaml]
----
Mw:
  Metamorph:
    facts:
      isFrontendUser:
        expr: |
          class.doesInherit('TYPO3\\CMS\\Extbase\\Domain\\Model\\FrontendUser') ||
          class.doesInherit('Tx_Extbase_Domain_Model_FrontendUser')
----

== Modifying source code inside transformations

Metamorph relies heavily on Nikita Popov's https://github.com/nikic/PHP-Parser[_PHP-Parser_ library] for parsing and modifying PHP source code. Source code transformation is accomplished by parsing PHP code into a http://en.wikipedia.org/wiki/Abstract_syntax_tree[syntax tree] using the PHP parser, then transforming that syntax tree according to your requirements and then dumping the tree back into source code.

Using the PHP Parser, this might look as follows:

[source,php]
----
$lexer   = new \PhpParser\Lexer();
$parser  = new \PhpParser\Parser($lexer);
$printer = new \PhpParser\PrettyPrinter\Standard();

$source = file_get_contents("Some/Source/Class.php");
$stmts  = $parser->parse($source);

// Do the magic on $stmts

file_put_contents("Some/Target/Class.php", $printer->prettyPrintFile($stmts));
----

In the above example, `$stmts` is simply a list of tree nodes (that is, instances of `PhpParser\Node`). While you could now walk this tree manually, it is usually easier to use the `PhpParser\NodeTraverser` class and providing a custom node http://en.wikipedia.org/wiki/Visitor_pattern[visitor]. For this, you need to implement the `PhpParser\NodeVisitor` interface, typically by extending the `PhpParser\NodeVisitorAbstract` class.

Consider the following visitor class that replaces the name of all defined classes with "Chocolate":

[source,php]
----
use PhpParser\NodeVisitorAbstract;
use PhpParser\Node;

class MyNodeVisitor extends NodeVisitorAbstract {
    public function leaveNode(Node $node) { // <1>
        if ($node instanceof Node\Stmt\Class_) {
            $node->name = "Chocolate";
            return $node; // <2>
        }
        return NULL; // <3>
    }
}
----
<1> This method is called for each node, when the traverser _leaves_ the node (effectively implementing a depth-first traversal of the tree). You can also implement the `enterNode(Node $node)` function to implement a breath-first search or even combine the two methods.
<2> If a node was modified by the visitor, it needs to be returned.
<3> Return `NULL` for unchanged nodes. You can also return `FALSE` to completely remove a node (and all sub-nodes) from the syntax tree.

You can call this visitor as follows:

[source,php]
----
$traverser = new \PhpParser\NodeTraverser();
$traverser->addVisitor(new MyNodeVisitor()); // <1>

$stmts = $traverser->traverse();
----
<1> You can actually add as many visitors as you like to a single traverser.
