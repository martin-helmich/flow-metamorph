<?php
namespace Mw\Metamorph\View\Prompt;

use Mw\Metamorph\Domain\Model\MorphConfiguration;
use Mw\Metamorph\Domain\Service\Dto\MorphCreationDto;
use Mw\Metamorph\View\DecoratedOutputInterface;
use Symfony\Component\Console\Helper\QuestionHelper;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Question\ChoiceQuestion;
use Symfony\Component\Console\Question\Question;
use TYPO3\Flow\Annotations as Flow;

class MorphCreationDataPrompt {

	/**
	 * @var InputInterface
	 */
	protected $input;

	/**
	 * @var DecoratedOutputInterface
	 */
	protected $output;

	/**
	 * @var QuestionHelper
	 */
	protected $questionHelper;

	public function __construct(InputInterface $input, DecoratedOutputInterface $output, QuestionHelper $helper) {
		$this->input          = $input;
		$this->output         = $output;
		$this->questionHelper = $helper;
	}

	public function setValuesOnCreateDto(MorphCreationDto $data) {
		$data->setSourceDirectory($this->getSourceDirectory());
		$data->setExtensionPatterns($this->getExtensionPatterns());
		$data->setTableStructureMode($this->getTableStructureMode());
		$data->setPibaseRefactoringMode($this->getPibaseRefactoringMode());
		$data->setVersionControlSystem($this->getVersionControlSystem());
	}

	/**
	 * @return string
	 */
	public function getSourceDirectory() {
		$this->printHeading('Source directory');
		$this->output->writeFormatted(
			'Please enter the path to the root directory of the TYPO3 CMS site that you want to migrate',
			4
		);

		$question = new Question('<comment>Source directory</comment>: ');
		return $this->questionHelper->ask($this->input, $this->output, $question);
	}

	/**
	 * @return array
	 */
	public function getExtensionPatterns() {
		$this->printHeading('Migrate extensions');
		$this->output->writeFormatted(
			'Please enter a list of regular expressions that extensions keys should match to be converted. You can ' .
			'enter multiple patterns in sequence; editing will stop when you insert an empty pattern. When you ' .
			'specify no pattern at all, all extensions will be converted.',
			4
		);

		$question = new Question('<comment>Enter regular expressions</comment>: ');

		$lastInput = FALSE;
		$patterns  = [];

		while ($lastInput !== NULL) {
			if ($lastInput) {
				$patterns[] = $lastInput;
			}
			$lastInput = $this->questionHelper->ask($this->input, $this->output, $question);
		}

		return $patterns;
	}

	/**
	 * @return bool
	 */
	public function getTableStructureMode() {
		$this->printHeading('Database structure');
		$this->output->writeFormatted(
			'Do you want to re-use the existing table structure? If you choose <info>KEEP</info>, Metamorph will use ' .
			'the existing table structures and enrich your doctrine models with the respective annotations.',
			4
		);

		$choices     = [
			MorphConfiguration::TABLE_STRUCTURE_KEEP    => "Keep tables as they are",
			MorphConfiguration::TABLE_STRUCTURE_MIGRATE => "Migrate to default structure generated by Doctrine"
		];
		$question    = new ChoiceQuestion('<comment>Table structure mode</comment>: ', $choices);
		$choiceLabel = $this->questionHelper->ask($this->input, $this->output, $question);

		return array_search($choiceLabel, $choices);
	}

	/**
	 * @return bool
	 */
	public function getPibaseRefactoringMode() {
		$this->printHeading('Refactoring mode');
		$this->output->writeFormatted(
			'Do you want to perform additional refactorings on piBase extensions? Please note that this might be ' .
			'dangerous.',
			4
		);

		$choices     = [
			MorphConfiguration::PIBASE_REFACTOR_CONSERVATIVE => "Do not touch the code, use compatibility APIs wherever possible",
			MorphConfiguration::PIBASE_REFACTOR_PROGRESSIVE  => "Refactor the code to use Flow APIs wherever possible"
		];
		$question    = new ChoiceQuestion('<comment>Refactoring mode</comment>: ', $choices);
		$choiceLabel = $this->questionHelper->ask($this->input, $this->output, $question);

		return array_search($choiceLabel, $choices);
	}

	/**
	 * @return string
	 */
	public function getVersionControlSystem() {
		$this->printHeading('Versioning');
		$this->output->writeFormatted(
			'Do you want metamorph to track changes to your package using a version control system?',
			4
		);
		return $this->promptChoice(
			'Version control system',
			[
				'GIT'  => 'Git',
				'NONE' => 'No versioning'
			]
		);
	}

	private function printHeading($heading) {
		$this->output->writeln('');
		$this->output->writeln('<info>' . strtoupper($heading) . '</info>');
	}

	private function promptChoice($prompt, array $allowedValues) {
		$question    = new ChoiceQuestion("<comment>$prompt</comment>: ", $allowedValues);
		$choiceLabel = $this->questionHelper->ask($this->input, $this->output, $question);
		return array_search($choiceLabel, $allowedValues);
	}

}